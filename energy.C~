/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | Copyright (C) 2011 OpenFOAM Foundation
     \\/     M anipulation  |
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.

Application
    enstrophy

Description
    Calculates and writes the enstrophy of the velocity field U.

    The -noWrite option just outputs the max/min values without writing the
    field.

\*---------------------------------------------------------------------------*/

#include "timeSelector.H"
#include "fvc.H"
#include "fvCFD.H"
#include "fixedGradientFvPatchFields.H"
#include <iostream>
#include <fstream>


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

namespace Foam
{

std::ofstream out;

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

void calc(const argList& args, const Time& runTime, const fvMesh& mesh)
{
    bool writeResults = !args.optionFound("noWrite");

     #include "readGravitationalAcceleration.H"


    word dictName="energy";

    IOdictionary analyticDict
        (
            IOobject
            (
                dictName,
                runTime.system(),
                mesh,
                IOobject::MUST_READ,
                IOobject::NO_WRITE
            )
        );

    scalar minZ = readScalar(analyticDict.lookup("minZ")); // .subDict("PIMPLE")

    volScalarField InteriorSelector("IS",mesh.C().component(0)); // dmmy inialization. 
    forAll(mesh.C(),cellid) { 
	InteriorSelector[cellid] = (mesh.C()[cellid].component(2) > minZ);
    }    


    // Calculating alpha. 
    volScalarField Tmean(IOobject(
			"Tmean",
			"0",
			mesh,
			IOobject::MUST_READ), 
		     	mesh); 

    
//    dimensionedScalar Theta_m = sum(Tmean*mesh.V())/sum(mesh.V()); // Should read from file like the solver!!!. (chekc that this is what the solver does)
	IOdictionary transportProperties
	(
		IOobject
		(
			"transportProperties",
			runTime.constant(),
			mesh,
			IOobject::MUST_READ,
			IOobject::NO_WRITE
		)
	);


    dimensionedScalar beta(transportProperties.lookup("beta"));
	
    volScalarField var = fvc::grad(Tmean)->component(2);
    dimensionedScalar small("f",var.dimensions(),scalar(1e-10));

    Info<< "Calculating alpha" << endl;
    volScalarField alpha("alpha", -InteriorSelector*beta*g.component(2)*pow((var+small),-1) );


    IOobject Uheader
    (
        "U",
        runTime.timeName(),
        mesh,
        IOobject::MUST_READ
    );

    IOobject Theader
    (
        "T",
        runTime.timeName(),
        mesh,
        IOobject::MUST_READ
    );

    if (Uheader.headerOk())
    {
        Info<< "    Reading U" << endl;
        volVectorField U(Uheader, mesh); 

        Info<< "    Reading T" << endl;
        volScalarField T(Theader, mesh); 

        Info<< "    Calculating kinetic energy " << endl;
        volScalarField KineticEnergy
        (
            IOobject
            (
                "KineticEnergy",
                runTime.timeName(),
                mesh,
                IOobject::NO_READ
            ),
            0.5*magSqr(U)
        );

        Info<< "    Calculating potential energy " << endl;
        volScalarField PotentialEnergy
        (
            IOobject
            (
                "PotentialEnergy",
                runTime.timeName(),
                mesh,
                IOobject::NO_READ
            ),
	   alpha*magSqr(T)            
        );

        if (writeResults)
        {
		KineticEnergy.write();
		PotentialEnergy.write();
        }

	Info << " Total Volume " << sum(mesh.V()) << endl; 
	Info << " Total kinetic energy " << sum(KineticEnergy*mesh.V()) << " | Mean potential energy " << sum(PotentialEnergy*mesh.V())  << endl;
	Info << " Mean kinetic energy " << sum(KineticEnergy*mesh.V())/sum(mesh.V()) << " | Mean potential energy " << sum(PotentialEnergy*mesh.V())/sum(mesh.V())  << endl;

	out  << runTime.timeName() << " " << sum(KineticEnergy*mesh.V()).value() << " " << sum(PotentialEnergy*mesh.V()).value() << " " << (sum(KineticEnergy*mesh.V())/sum(mesh.V())).value() << " " << (sum(PotentialEnergy*mesh.V())/sum(mesh.V())).value() << std::endl; 

    }
    else
    {
        Info<< "    No U or T" << endl;
    }

    Info<< "\nEnd\n" << endl;
}

void tryCalc(const argList& args, const Time& runTime, const fvMesh& mesh)
    {
        FatalIOError.throwExceptions();
        try
        {
            calc(args, runTime, mesh);
        }
        catch(IOerror& err)
        {
            Warning<< err << endl;
        }
    }
}

// ************************************************************************* //
int main(int argc, char *argv[])
{
    Foam::timeSelector::addOptions();
#   include "addRegionOption.H"
    Foam::argList::addBoolOption
    (
        "noWrite",
        "suppress writing results"
    );
    #include "addDictOption.H"

    #include "setRootCase.H"
    #include "createTime.H"
    Foam::instantList timeDirs = Foam::timeSelector::select0(runTime, args);
    #include "createNamedMesh.H"


    out.open ("EnergyIntegral.txt");
    out << "# Time TotalKineticEnergy TotalPotentialEnergy MeanKineticEnergy MeanPotentialEnergy " << std::endl;

    forAll(timeDirs, timeI)
    {
        runTime.setTime(timeDirs[timeI], timeI);

        Foam::Info<< "Time = " << runTime.timeName() << Foam::endl;

        mesh.readUpdate();

        Foam::tryCalc(args, runTime, mesh);

        Foam::Info<< Foam::endl;
    }
    out.close();
}
// ************************************************************************* //
